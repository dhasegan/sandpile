<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sandpile Avalanche Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 900px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .instructions {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .game-area {
            display: flex;
            gap: 30px;
            margin-top: 20px;
        }

        .grid-container {
            flex: 1;
        }

        .grid {
            display: grid;
            gap: 2px;
            background: #ddd;
            padding: 2px;
            border-radius: 8px;
            margin: 0 auto;
        }

        .cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2em;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
            border-radius: 4px;
        }

        .cell:hover {
            transform: scale(1.1);
            z-index: 10;
        }

        .cell.height-0 { background: #f0f0f0; color: #ccc; }
        .cell.height-1 { background: #fff4e6; color: #e67e22; }
        .cell.height-2 { background: #ffe4b3; color: #d35400; }
        .cell.height-3 { background: #ffb347; color: #a04000; }
        .cell.height-4 { background: #ff6b35; color: white; }

        .stats {
            flex: 0 0 250px;
        }

        .stat-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .stat-box h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .player-turn {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background: linear-gradient(135deg, #e74c3c 0%, #3498db 100%);
            border-radius: 10px;
            color: white;
            font-size: 1.3em;
            font-weight: bold;
        }

        .player-scores {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }

        .player-score-box {
            flex: 1;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 3px solid transparent;
            transition: all 0.3s;
        }

        .player-score-box.active {
            border-color: #e74c3c;
            background: #ffe8e6;
        }

        .player-score-box.active:last-child {
            border-color: #3498db;
            background: #e3f2fd;
        }

        .player-score-box h3 {
            color: #333;
            margin-bottom: 8px;
            font-size: 1em;
        }

        .player-score-value {
            font-size: 1.8em;
            font-weight: bold;
        }

        #player1Score {
            color: #e74c3c;
        }

        #player2Score {
            color: #3498db;
        }

        .player-1 { color: #e74c3c; }
        .player-2 { color: #3498db; }

        .avalanche-history {
            max-height: 300px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }

        .avalanche-history h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .avalanche-item {
            padding: 8px;
            margin: 5px 0;
            background: white;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .avalanche-size {
            font-weight: bold;
            color: #667eea;
        }

        .controls {
            text-align: center;
            margin-top: 20px;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.3s;
        }

        button:hover {
            background: #5568d3;
        }

        .grid-size-control {
            text-align: center;
            margin-bottom: 20px;
        }

        .grid-size-control label {
            margin-right: 10px;
            color: #666;
        }

        .grid-size-control input {
            width: 60px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .toppling {
            animation: topple 0.3s ease;
        }

        @keyframes topple {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); background-color: #ff3333; }
        }

        .power-law-plot {
            margin-top: 30px;
            background: white;
            padding: 20px;
            border-radius: 8px;
        }

        .power-law-plot h2 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 1.3em;
        }

        .plot-description {
            text-align: center;
            color: #666;
            font-size: 0.9em;
            margin-bottom: 15px;
        }

        #powerLawCanvas {
            display: block;
            margin: 0 auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèîÔ∏è Sandpile Avalanche Game</h1>
        <div class="instructions">
            Two-player competitive game! The board starts with random sand grains (1-3 per cell). Players take turns clicking cells to add grains. Between turns, random grains are added automatically. When a cell reaches 4 grains, it topples and distributes sand to neighbors, creating avalanches. Score points for each topple you trigger - highest score wins!
        </div>

        <div class="grid-size-control">
            <label for="gridSize">Grid Size:</label>
            <input type="number" id="gridSize" min="5" max="30" value="15">
            <label for="randomAdds" style="margin-left: 20px;">Random Adds Between Turns:</label>
            <input type="number" id="randomAdds" min="0" max="10" value="2">
            <button onclick="resetGame()">New Game</button>
        </div>

        <div class="player-turn" id="playerTurn">
            Player 1's Turn
        </div>

        <div class="game-area">
            <div class="grid-container">
                <div id="grid" class="grid"></div>
            </div>

            <div class="stats">
                <div class="player-scores">
                    <div class="player-score-box active" id="player1Box">
                        <h3 class="player-1">Player 1</h3>
                        <div class="player-score-value" id="player1Score">0</div>
                    </div>
                    <div class="player-score-box" id="player2Box">
                        <h3 class="player-2">Player 2</h3>
                        <div class="player-score-value" id="player2Score">0</div>
                    </div>
                </div>

                <div class="stat-box">
                    <h3>Moves Made</h3>
                    <div class="stat-value" id="moveCount">0</div>
                </div>

                <div class="stat-box">
                    <h3>Largest Avalanche</h3>
                    <div class="stat-value" id="maxAvalanche">0</div>
                </div>

                <div class="avalanche-history">
                    <h3>Avalanche History</h3>
                    <div id="history"></div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button onclick="resetGame()">Reset Game</button>
        </div>

        <div class="power-law-plot">
            <h2>üìä Power-Law Distribution (1/f Plot)</h2>
            <div class="plot-description">
                Stacked bar chart with logarithmic x-axis binning: [1-2], [3-4], [5-8], [9-16], ..., up to [513-1024].
                X-axis: Log‚ÇÇ scale (avalanche sizes). Y-axis: Linear scale (event count, 0-10 baseline, auto-scales upward).
                Red = Player 1, Blue = Player 2, Gray = Random additions. Power-law behavior shows as right-skewed distribution.
            </div>
            <canvas id="powerLawCanvas" width="700" height="400"></canvas>
        </div>
    </div>

    <script>
        class SandpileGame {
            constructor(size, randomAdds) {
                this.size = size;
                this.randomAdds = randomAdds;
                // Initialize grid with random values from 1 to 3
                this.grid = Array(size).fill(0).map(() =>
                    Array(size).fill(0).map(() => Math.floor(Math.random() * 3) + 1)
                );
                this.player1Score = 0;
                this.player2Score = 0;
                this.currentPlayer = 1;
                this.moveCount = 0;
                this.maxAvalanche = 0;
                this.avalancheHistory = [];

                // Track avalanche size distributions for power-law plot
                this.player1Avalanches = {}; // {size: count}
                this.player2Avalanches = {}; // {size: count}
                this.randomAvalanches = {}; // {size: count}

                this.setupCanvas();
            }

            setupCanvas() {
                this.canvas = document.getElementById('powerLawCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.drawPowerLawPlot();
            }

            addRandomGrains() {
                for (let n = 0; n < this.randomAdds; n++) {
                    const row = Math.floor(Math.random() * this.size);
                    const col = Math.floor(Math.random() * this.size);
                    this.grid[row][col]++;
                }

                // Topple any resulting avalanches and track them
                const avalancheSize = this.topple();
                if (avalancheSize > 0) {
                    this.randomAvalanches[avalancheSize] = (this.randomAvalanches[avalancheSize] || 0) + 1;
                }

                this.updateDisplay();
                this.drawPowerLawPlot();
            }

            addGrain(row, col) {
                this.grid[row][col]++;
                this.moveCount++;

                const avalancheSize = this.topple();

                if (avalancheSize > 0) {
                    if (this.currentPlayer === 1) {
                        this.player1Score += avalancheSize;
                        // Track avalanche size for player 1
                        this.player1Avalanches[avalancheSize] = (this.player1Avalanches[avalancheSize] || 0) + 1;
                    } else {
                        this.player2Score += avalancheSize;
                        // Track avalanche size for player 2
                        this.player2Avalanches[avalancheSize] = (this.player2Avalanches[avalancheSize] || 0) + 1;
                    }
                    this.maxAvalanche = Math.max(this.maxAvalanche, avalancheSize);
                    this.avalancheHistory.unshift({
                        move: this.moveCount,
                        player: this.currentPlayer,
                        size: avalancheSize,
                        position: `(${row}, ${col})`
                    });
                }

                // Switch players
                this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;

                this.updateDisplay();
                this.drawPowerLawPlot(); // Update the plot

                // Add random grains after player move
                if (this.randomAdds > 0) {
                    setTimeout(() => this.addRandomGrains(), 300);
                }
            }

            topple() {
                let totalTopples = 0;
                let changed = true;
                const toppledCells = new Set();

                while (changed) {
                    changed = false;
                    const currentTopples = [];

                    for (let i = 0; i < this.size; i++) {
                        for (let j = 0; j < this.size; j++) {
                            if (this.grid[i][j] >= 4) {
                                currentTopples.push([i, j]);
                                changed = true;
                            }
                        }
                    }

                    for (const [i, j] of currentTopples) {
                        this.grid[i][j] -= 4;
                        totalTopples++;
                        toppledCells.add(`${i},${j}`);

                        // Add to neighbors
                        if (i > 0) this.grid[i - 1][j]++;
                        if (i < this.size - 1) this.grid[i + 1][j]++;
                        if (j > 0) this.grid[i][j - 1]++;
                        if (j < this.size - 1) this.grid[i][j + 1]++;

                        // Visual feedback
                        this.animateTopple(i, j);
                    }

                    if (changed) {
                        // Small delay to show the avalanche propagation
                        this.updateDisplay();
                    }
                }

                return totalTopples;
            }

            animateTopple(row, col) {
                const cellId = `cell-${row}-${col}`;
                const cell = document.getElementById(cellId);
                if (cell) {
                    cell.classList.add('toppling');
                    setTimeout(() => cell.classList.remove('toppling'), 300);
                }
            }

            updateDisplay() {
                // Update grid
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        const cell = document.getElementById(`cell-${i}-${j}`);
                        const height = this.grid[i][j];
                        cell.textContent = height;
                        cell.className = `cell height-${Math.min(height, 4)}`;
                    }
                }

                // Update current player indicator
                const playerTurnDiv = document.getElementById('playerTurn');
                playerTurnDiv.textContent = `Player ${this.currentPlayer}'s Turn`;

                // Update player score boxes
                document.getElementById('player1Box').classList.toggle('active', this.currentPlayer === 1);
                document.getElementById('player2Box').classList.toggle('active', this.currentPlayer === 2);

                // Update stats
                document.getElementById('player1Score').textContent = this.player1Score;
                document.getElementById('player2Score').textContent = this.player2Score;
                document.getElementById('moveCount').textContent = this.moveCount;
                document.getElementById('maxAvalanche').textContent = this.maxAvalanche;

                // Update history
                const historyDiv = document.getElementById('history');
                historyDiv.innerHTML = this.avalancheHistory.slice(0, 20).map(av => `
                    <div class="avalanche-item">
                        <span>P${av.player} Move ${av.move} at ${av.position}</span>
                        <span class="avalanche-size">${av.size} topples</span>
                    </div>
                `).join('');
            }

            renderGrid() {
                const gridDiv = document.getElementById('grid');
                gridDiv.style.gridTemplateColumns = `repeat(${this.size}, 1fr)`;
                gridDiv.innerHTML = '';

                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        const cell = document.createElement('div');
                        cell.id = `cell-${i}-${j}`;
                        const height = this.grid[i][j];
                        cell.className = `cell height-${Math.min(height, 4)}`;
                        cell.textContent = height;
                        cell.onclick = () => this.addGrain(i, j);
                        gridDiv.appendChild(cell);
                    }
                }
            }

            drawPowerLawPlot() {
                const ctx = this.ctx;
                const canvas = this.canvas;
                const width = canvas.width;
                const height = canvas.height;

                // Clear canvas
                ctx.clearRect(0, 0, width, height);

                // Set margins
                const margin = { top: 20, right: 30, bottom: 60, left: 70 };
                const plotWidth = width - margin.left - margin.right;
                const plotHeight = height - margin.top - margin.bottom;

                // Combine all avalanche sizes to determine range
                const allSizes = new Set([
                    ...Object.keys(this.player1Avalanches).map(Number),
                    ...Object.keys(this.player2Avalanches).map(Number),
                    ...Object.keys(this.randomAvalanches).map(Number)
                ]);

                // Create logarithmic bins up to 1024: [1-2], [3-4], [5-8], [9-16], [17-32], [33-64], etc.
                const maxBinSize = 1024;
                const bins = [];
                let binStart = 1;

                while (binStart <= maxBinSize) {
                    const binEnd = binStart === 1 ? 2 : binStart * 2 - 1;
                    bins.push({ start: binStart, end: Math.min(binEnd, maxBinSize), index: bins.length });
                    binStart = binEnd + 1;
                }

                if (allSizes.size === 0) {
                    // Draw empty plot with axes
                    const logMaxSize = Math.ceil(Math.log2(maxBinSize + 1));
                    this.drawAxes(ctx, margin, plotWidth, plotHeight, 1, Math.pow(2, logMaxSize), 0, 10);
                    ctx.fillStyle = '#999';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Play some moves to see the power-law distribution!', width / 2, height / 2);
                    return;
                }

                // Aggregate data into bins
                const binData = bins.map(bin => {
                    let p1Count = 0, p2Count = 0, randCount = 0;

                    for (let size = bin.start; size <= bin.end; size++) {
                        p1Count += this.player1Avalanches[size] || 0;
                        p2Count += this.player2Avalanches[size] || 0;
                        randCount += this.randomAvalanches[size] || 0;
                    }

                    return { bin, p1Count, p2Count, randCount, total: p1Count + p2Count + randCount };
                });

                // Calculate max count for scaling
                const maxCount = Math.max(...binData.map(d => d.total), 1);

                // Linear scale ranges - start from 0 to 10, scale up if needed
                const logMaxSize = Math.ceil(Math.log2(maxBinSize + 1));
                const yMin = 0;
                const yMax = Math.max(10, maxCount);

                // Draw axes
                this.drawAxes(ctx, margin, plotWidth, plotHeight,
                    1, Math.pow(2, logMaxSize),
                    yMin, yMax);

                // Draw bars with constant width in log space
                const totalBins = bins.length;
                const barWidth = plotWidth / totalBins;

                binData.forEach((data, index) => {
                    // Calculate bar position - constant width for each bin
                    const barX = margin.left + index * barWidth;

                    if (data.total === 0) return;

                    // Draw stacked bars from bottom to top using linear scale
                    let currentY = margin.top + plotHeight;

                    // Player 1 (red) - bottom
                    if (data.p1Count > 0) {
                        const barHeight = (data.p1Count / yMax) * plotHeight;
                        const barY = currentY - barHeight;

                        ctx.fillStyle = '#e74c3c';
                        ctx.fillRect(barX, barY, barWidth, barHeight);
                        currentY = barY;
                    }

                    // Player 2 (blue) - middle
                    if (data.p2Count > 0) {
                        const cumulativeCount = data.p1Count + data.p2Count;
                        const totalHeight = (cumulativeCount / yMax) * plotHeight;
                        const barHeight = totalHeight - (margin.top + plotHeight - currentY);
                        const barY = currentY - barHeight;

                        ctx.fillStyle = '#3498db';
                        ctx.fillRect(barX, barY, barWidth, barHeight);
                        currentY = barY;
                    }

                    // Random (gray) - top
                    if (data.randCount > 0) {
                        const totalHeight = (data.total / yMax) * plotHeight;
                        const barHeight = totalHeight - (margin.top + plotHeight - currentY);
                        const barY = currentY - barHeight;

                        ctx.fillStyle = '#95a5a6';
                        ctx.fillRect(barX, barY, barWidth, barHeight);
                    }

                    // Draw bar outline
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 0.5;
                    const totalBarHeight = (data.total / yMax) * plotHeight;
                    ctx.strokeRect(barX, margin.top + plotHeight - totalBarHeight, barWidth, totalBarHeight);
                });

                // Draw legend
                this.drawLegend(ctx, width, margin);
            }

            drawAxes(ctx, margin, plotWidth, plotHeight, minX, maxX, minY, maxY) {
                const width = this.canvas.width;
                const height = this.canvas.height;

                // Draw axes lines
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                // Y-axis
                ctx.moveTo(margin.left, margin.top);
                ctx.lineTo(margin.left, margin.top + plotHeight);
                // X-axis
                ctx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
                ctx.stroke();

                // Draw grid and labels
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.fillStyle = '#666';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';

                // X-axis ticks and grid (log2 scale - powers of 2)
                const logMinX = Math.log2(minX);
                const logMaxX = Math.log2(maxX);

                for (let i = Math.ceil(logMinX); i <= logMaxX; i++) {
                    const value = Math.pow(2, i);
                    const x = margin.left + ((i - logMinX) / (logMaxX - logMinX)) * plotWidth;

                    // Grid line
                    ctx.beginPath();
                    ctx.moveTo(x, margin.top);
                    ctx.lineTo(x, margin.top + plotHeight);
                    ctx.stroke();

                    // Label
                    ctx.fillText(value, x, margin.top + plotHeight + 20);
                }

                // Y-axis ticks and grid (linear scale)
                // Calculate appropriate tick interval
                const range = maxY - minY;
                let tickInterval;
                if (range <= 10) {
                    tickInterval = 1;
                } else if (range <= 20) {
                    tickInterval = 2;
                } else if (range <= 50) {
                    tickInterval = 5;
                } else if (range <= 100) {
                    tickInterval = 10;
                } else {
                    tickInterval = Math.ceil(range / 10);
                }

                // Draw tick marks at regular intervals
                for (let value = minY; value <= maxY; value += tickInterval) {
                    const y = margin.top + plotHeight - ((value - minY) / (maxY - minY)) * plotHeight;

                    // Grid line
                    ctx.beginPath();
                    ctx.moveTo(margin.left, y);
                    ctx.lineTo(margin.left + plotWidth, y);
                    ctx.stroke();

                    // Label
                    ctx.textAlign = 'right';
                    ctx.fillText(Math.round(value), margin.left - 10, y + 4);
                }

                // Axis labels
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';

                // X-axis label
                ctx.fillText('Avalanche Size (log‚ÇÇ scale)', margin.left + plotWidth / 2, height - 10);

                // Y-axis label
                ctx.save();
                ctx.translate(15, margin.top + plotHeight / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('Number of Events', 0, 0);
                ctx.restore();
            }

            drawLegend(ctx, width, margin) {
                const legendX = width - margin.right - 130;
                const legendY = margin.top + 10;

                ctx.font = '12px Arial';

                // Player 1
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(legendX, legendY - 4, 12, 12);
                ctx.fillStyle = '#333';
                ctx.textAlign = 'left';
                ctx.fillText('Player 1', legendX + 18, legendY + 4);

                // Player 2
                ctx.fillStyle = '#3498db';
                ctx.fillRect(legendX, legendY + 16, 12, 12);
                ctx.fillStyle = '#333';
                ctx.fillText('Player 2', legendX + 18, legendY + 24);

                // Random
                ctx.fillStyle = '#95a5a6';
                ctx.fillRect(legendX, legendY + 36, 12, 12);
                ctx.fillStyle = '#333';
                ctx.fillText('Random', legendX + 18, legendY + 44);
            }
        }

        let game;

        function initGame() {
            const size = parseInt(document.getElementById('gridSize').value) || 15;
            const randomAdds = parseInt(document.getElementById('randomAdds').value) || 0;
            game = new SandpileGame(size, randomAdds);
            game.renderGrid();
            game.updateDisplay();
        }

        function resetGame() {
            initGame();
        }

        // Initialize game on load
        initGame();
    </script>
</body>
</html>
